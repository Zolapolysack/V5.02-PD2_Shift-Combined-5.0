<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Language" content="th" />
  <!-- Added meta enhancements -->
  <meta name="description" content="ระบบบันทึกข้อมูลกะ A/B ตัดม้วน และรายงาน แผนกผลิต 2 - ใช้งานได้ทั้งออฟไลน์และออนไลน์" />
  <meta name="theme-color" content="#0a0a0a" />
  <meta name="color-scheme" content="light dark" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <!-- Runtime API binding for production: replace content with your deployed API URL -->
  <meta name="pd2-api" content="https://YOUR_DEPLOYED_API_SERVER_URL_HERE" />
  <title>ระบบบันทึกข้อมูลรายงานแผนกผลิต 2</title>
  <script src="https://cdn.tailwindcss.com/3.4.10"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Preload Kanit to improve FCP -->
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Kanit:wght@200;300;400;500;600&display=swap" />
  <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@200;300;400;500;600&display=swap" rel="stylesheet">
  <!-- Load shared PD2 notification module once at the parent level -->
  <script src="./pd2-notify.js" defer></script>
  <!-- PWA: manifest + icons -->
  <link rel="manifest" href="./manifest.json">
  <!-- Use root images.png as a single source icon; browsers will scale as needed. Replace with proper sizes if available. -->
  <link rel="icon" href="./images.png" sizes="192x192" />
  <link rel="apple-touch-icon" href="./images.png" />
  <style>
    :root { --pd2-green:#16a34a; --pd2-green-accent:#22c55e; --pd2-red:#f43f5e; --pd2-blue:#24a8ea; --pd2-purple:#6d28d9; }
    * { font-family: 'Kanit', sans-serif; }
    body { background: linear-gradient(135deg, #0a0a0a 50%, #0ea5e9 100%); min-height: 100vh; }
    .glass { background: rgba(255,255,255,0.1); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); }
    .tab-btn { transition: all .2s ease; }
    .tab-btn.active { background: linear-gradient(135deg, var(--pd2-green-accent), var(--pd2-green)); color: #fff; border-color:var(--pd2-green); }
    .tab-btn:not(.active) { background: rgba(255,255,255,0.9); color:#111827; border-color:#e5e7eb; }
    .frame-wrap { height: calc(100vh - 112px); /* header(32)+box(80)≈112 */ }
    @media (max-width: 768px) { .frame-wrap { height: calc(100vh - 140px); } }
    .hero-blur { -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
    /* Loading overlay for iframe navigation */
    .loading-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.85); z-index:40; }
    .loading-hidden { display:none; }
    .pill-btn[disabled] { opacity:.55; cursor:not-allowed; }
    /* Pro look helpers */
    .gradient-text { font-weight: 700; background: linear-gradient(90deg,#ffffff 0%,#f3f4f6 35%,#e5e7eb 65%,#cbd5d1 100%); -webkit-background-clip: text; background-clip: text; color: transparent; -webkit-text-stroke: 0; text-shadow: 0 1px 0 rgba(0,0,0,0.10); filter: none; letter-spacing: 0.2px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .sticky-card { position: sticky; top: 1rem; z-index: 50; }
    .pill-group { background: rgba(255,255,255,0.85); border: 1px solid rgba(255,255,255,0.65); padding: .25rem; border-radius: .875rem; display: inline-flex; gap: .25rem; }
    .pill-btn { position: relative; padding: .625rem 1.125rem; border-radius: .85rem; font-weight: 400; color:#0f172a; transition: transform .2s ease, box-shadow .2s ease, background-color .2s ease, color .2s ease; will-change: transform, box-shadow; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,.06); }
    .pill-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,.12); }
    .pill-btn:active { transform: translateY(0); box-shadow: 0 3px 10px rgba(0,0,0,.1); }
    .pill-btn:focus-visible { outline: none; box-shadow: 0 0 0 2px rgba(255,255,255,.7), 0 8px 20px rgba(0,0,0,.18); }
    .pill-btn::after { content: ""; position: absolute; inset: -1px; background: radial-gradient(120px 60px at var(--x,10%) 50%, rgba(255,255,255,.35), transparent 60%); opacity: 0; transition: opacity .25s ease; pointer-events: none; }
    .pill-btn:hover::after { opacity: .6; }
    .pill-btn.active { background: linear-gradient(135deg, var(--pd2-green-accent), var(--pd2-green)); color:#fff; box-shadow: 0 14px 30px rgba(34,197,94,.28), 0 0 0 1px rgba(255,255,255,.25) inset; }
    #btnB.pill-btn.active { background: linear-gradient(135deg, #ef4444, var(--pd2-red)); box-shadow: 0 14px 30px rgba(244,63,94,.28), 0 0 0 1px rgba(255,255,255,.25) inset; }
    #btnCut.pill-btn.active { background: linear-gradient(135deg, #05a3e6, var(--pd2-blue)); box-shadow: 0 14px 30px rgba(245,158,11,.28), 0 0 0 1px rgba(255,255,255,.25) inset; }
    #btnReport.pill-btn.active { background: linear-gradient(135deg, #4c1d95, var(--pd2-purple)); box-shadow: 0 14px 30px rgba(109,40,217,.28), 0 0 0 1px rgba(255,255,255,.25) inset; }
    .bg-grid { background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.12) 1px, transparent 0); background-size: 22px 22px; }
    .spotlight { position: absolute; inset: 0; opacity: .8; mix-blend-mode: screen; }
    .spotlight:before, .spotlight:after { content: ""; position: absolute; border-radius: 9999px; filter: blur(60px); }
    .spotlight:before { width: 480px; height: 480px; left: -120px; top: -140px; background: radial-gradient(circle, rgba(34,211,238,.35), transparent 60%); }
    .spotlight:after { width: 540px; height: 540px; right: -160px; bottom: -180px; background: radial-gradient(circle, rgba(167,139,250,.35), transparent 60%); }
  </style>
  <style id="pd2-reduced-motion-global">
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        transition: none !important;
        animation: none !important;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }
    }
  </style>
</head>
<!-- mobile responsive fix: add bottom safe-area padding for Android navbar avoidance -->
<body class="min-h-screen pb-[env(safe-area-inset-bottom,0)]" style="overflow-x:hidden;">
  <!-- Skip to main content link -->
  <a href="#workbench" class="sr-only focus:not-sr-only focus:absolute focus:top-2 focus:left-2 bg-black/70 text-white px-3 py-2 rounded">ข้ามไปยังพื้นที่ทำงาน</a>
  <!-- Top Nav / Brand -->
  <header class="mx-4 mt-4">
    <div class="glass sticky-card rounded-xl p-3 flex items-center justify-between shadow-lg ring-1 ring-white/20">
      <div class="flex items-center gap-3">
        <div class="relative">
          <div class="w-10 h-10 rounded-lg bg-gradient-to-br from-cyan-400 to-blue-600 shadow-inner"></div>
          <!-- Brand image points to images.png (placed at workspace root) -->
          <img id="brandImg" src="images.png" alt="Brand" class="absolute inset-0 z-10 w-10 h-10 rounded-lg object-cover ring-1 ring-white/40" onerror="this.remove()" />
        </div>
        <div class="leading-tight">
          <div class="text-white text-lg font-semibold">Production Dept. 2</div>
          <div class="text-white/70 text-sm">Shift A+B Unified Console</div>
        </div>
      </div>
      <nav class="hidden sm:flex items-center gap-3 text-sm">
  <a href="#overview" class="px-3 py-2 rounded-md border border-white/30 text-white/90 hover:text-white hover:bg-white/10 hover:border-white/60 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/60">ภาพรวม</a>
  <a href="#shift" class="px-3 py-2 rounded-md border border-white/30 text-white/90 hover:text-white hover:bg-white/10 hover:border-white/60 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/60">เลือกกะ</a>
  <a href="#workbench" class="px-3 py-2 rounded-md border border-white/30 text-white/90 hover:text-white hover:bg-white/10 hover:border-white/60 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/60">หน้าทำงาน</a>
  <div class="relative" id="pd2ResetWrap">
    <button id="pd2ResetBtn" type="button" class="px-3 py-2 rounded-md border border-rose-400/60 text-rose-200 hover:text-white hover:bg-rose-500/20 hover:border-rose-300 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-rose-300/70 relative" title="รีเซ็ตระบบ">
      <span class="select-none">รีเซ็ตระบบ ▾</span>
      <span class="absolute -top-1 -right-1 w-2.5 h-2.5 rounded-full bg-rose-400 shadow-md ring-2 ring-rose-900/60 animate-pulse"></span>
    </button>
    <div id="pd2ResetMenu" class="hidden absolute right-0 mt-1 w-56 rounded-md border border-white/15 bg-slate-900/95 backdrop-blur px-2 py-2 shadow-lg z-50">
      <div class="text-[11px] uppercase tracking-wide text-slate-400 mb-1 px-1">รีเซ็ต</div>
      <button data-mode="partial" class="pd2-reset-item w-full text-left text-sm rounded px-2 py-1.5 hover:bg-slate-700/60 text-slate-200">
        รีเซ็ตบางส่วน

      </button>
      <button data-mode="full" class="pd2-reset-item w-full text-left text-sm rounded px-2 py-1.5 hover:bg-rose-600/30 text-rose-300">
        รีเซ็ตทั้งหมด
        <!-- removed -->
      </button>
    </div>
  </div>
      </nav>
    </div>
  </header>

  <!-- Hero Section -->
  <main id="main" role="main">
  <!-- mobile responsive fix: reduce hero min height on very small screens -->
  <section class="relative overflow-hidden mt-4 mx-4 rounded-2xl min-h-[240px] sm:min-h-[280px] md:min-h-[360px] flex items-center">
    <div class="absolute inset-0 -z-10">
      <div class="absolute -top-24 -left-24 w-80 h-80 bg-cyan-400/30 rounded-full blur-3xl"></div>
      <div class="absolute -bottom-24 -right-24 w-96 h-96 bg-purple-500/30 rounded-full blur-3xl"></div>
  <div class="absolute inset-0 bg-gradient-to-br from-white/10 to-white/0 hero-blur"></div>
    </div>
    <div class="w-full glass rounded-2xl bg-grid relative">
      <div class="spotlight" aria-hidden="true"></div>
      <div class="px-6 py-8 md:px-10 md:py-12">
        <div class="max-w-full text-left">
          <!-- mobile responsive fix: allow wrapping on small screens to prevent overflow -->
          <h1 class="gradient-text whitespace-normal sm:whitespace-nowrap break-words tracking-tight text-[clamp(1rem,4vw,2.6rem)] md:text-[clamp(1.75rem,3.2vw,3rem)] font-semibold leading-tight">ระบบบันทึกข้อมูลกะ A & B และตัดม้วนผ้า PD2 </h1>
          <p class="text-white/85 mt-3 whitespace-normal sm:whitespace-nowrap text-[clamp(0.9rem,2.2vw,1.125rem)]">รวมการทำงานของทั้งสองกะสามารถสลับกะได้ บันทึกข้อมูล รองรับการใช้งานทั้งออนไลน์และออฟไลน์</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Overview / Features -->
  <section id="overview" class="mx-4 mt-8">
    <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
      <div class="glass rounded-xl p-6 text-center h-full">
        <div class="text-white text-xl font-medium flex items-center justify-center gap-2">
          <!-- Save (Floppy) -->
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M6 3h9l3 3v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z" stroke="white" stroke-width="1.5"/>
            <path d="M8 3h5v5H8z" stroke="white" stroke-width="1.5"/>
            <path d="M8 21v-6h8v6" stroke="white" stroke-width="1.5"/>
          </svg>
          <span>บันทึกอัตโนมัติ</span>
        </div>
        <p class="text-white/85 text-base mt-2">เซฟข้อมูลอัตโนมัติระหว่างพิมพ์ ลดโอกาสข้อมูลสูญหาย</p>
      </div>
      <div class="glass rounded-xl p-6 text-center h-full">
        <div class="text-white text-xl font-medium flex items-center justify-center gap-2">
          <!-- Offline (Cloud with slash) -->
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M8 18H7a4 4 0 1 1 0-8c.4-2.9 2.9-5 6-5a6 6 0 0 1 6 6" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M3 3l18 18" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
          <span>ใช้งานได้แม้ออฟไลน์</span>
        </div>
        <p class="text-white/85 text-base mt-2">รองรับการทำงานออฟไลน์ และซิงก์เมื่อกลับมาออนไลน์</p>
      </div>
      <div class="glass rounded-xl p-6 text-center h-full">
        <div class="text-white text-xl font-medium flex items-center justify-center gap-2">
          <!-- Recovery (Rotate arrows) -->
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M21 12a9 9 0 1 1-3-6.7" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M21 3v6h-6" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>กู้คืนฉุกเฉิน</span>
        </div>
        <p class="text-white/85 text-base mt-2">ระบบยืนยันและดำเนินการต่อรายการที่ค้าง </p>
      </div>
      <div class="glass rounded-xl p-6 text-center h-full">
        <div class="text-white text-xl font-medium flex items-center justify-center gap-2">
          <!-- Secure Sheets (Shield with check) -->
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 3l7 3v6c0 5-3.3 9-7 9s-7-4-7-9V6l7-3z" stroke="white" stroke-width="1.5"/>
            <path d="M9.5 12.5l2 2 3-3" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span>ส่งขึ้นชีตอย่างปลอดภัย</span>
        </div>
        <p class="text-white/85 text-base mt-2"> เชื่อมต่อกับ Google Sheets ผ่าน API และจัดเก็บข้อมูลสำรอง</p>
      </div>
    </div>

    
  </section>

  <!-- Shift Selector -->
  <section id="shift" class="mx-4 mt-6">
    <div class="glass rounded-2xl p-5 ring-1 ring-white/15">
      <div class="flex flex-col gap-4">
        <div class="text-center">
          <div class="text-white/90 text-xl md:text-2xl font-medium">เลือกกะสำหรับใช้งาน</div>
          <div class="text-sm md:text-base text-white/70">สามารถสลับได้ ข้อมูลจะยังอยู่ตามกะที่เลือก</div>
        </div>
        <div class="flex justify-center">
          <!-- mobile responsive fix: allow buttons to wrap on small screens -->
          <div class="pill-group shadow-md w-full md:w-[720px] lg:w-[800px] flex-wrap sm:flex-nowrap gap-2">
            <button id="btnA" aria-pressed="true" aria-controls="workbench" class="pill-btn active text-base md:text-lg ring-1 ring-black/0 hover:ring-black/5 flex-1">บันทึกข้อมูลกะ A</button>
            <button id="btnB" aria-pressed="false" aria-controls="workbench" class="pill-btn text-base md:text-lg ring-1 ring-black/0 hover:ring-black/5 flex-1">บันทึกข้อมูลกะ B</button>
            <button id="btnCut" aria-pressed="false" aria-controls="workbench" class="pill-btn text-base md:text-lg ring-1 ring-black/0 hover:ring-black/5 flex-1">บันทึกตัดม้วน</button>
            <button id="btnReport" aria-pressed="false" aria-controls="workbench" class="pill-btn text-base md:text-lg ring-1 ring-black/0 hover:ring-black/5 flex-1">รายงาน</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  

  <!-- Workbench / Iframe -->
  <section id="workbench" class="mx-4 mt-4 mb-6">
    <div class="glass rounded-2xl p-2 ring-1 ring-white/10">
  <div class="frame-wrap rounded-xl overflow-hidden bg-white/90 shadow-lg ring-1 ring-black/5 relative">
    <!-- Note: This file is placed as a sibling folder of A/B. Adjust relative paths if moved. -->
  <iframe id="shiftFrame" title="Shift Frame" class="w-full h-full border-0" loading="eager"></iframe>
  <!-- Loading overlay shown during iframe navigation -->
  <div id="frameLoading" class="loading-overlay loading-hidden">
    <div class="flex flex-col items-center gap-3 text-slate-700">
      <div class="h-8 w-8 rounded-full border-4 border-slate-300 border-t-cyan-500 animate-spin"></div>
      <div id="frameLoadingLabel" class="text-sm">กำลังโหลดโมดูล...</div>
    </div>
  </div>
      </div>
    </div>
  </section>
  </main>
  <!-- Footer -->
  <footer class="mx-4 mb-6 mt-10">
    <div class="glass rounded-xl p-4 flex flex-col md:flex-row md:items-center md:justify-between gap-2 text-sm">
  <div class="text-white/70">© 2025 Production Dept. 2 • Unified Shift Console v5.02</div>
      <div class="text-white/60">รองรับการใช้งานบนอุปกรณ์พกพา และเบราว์เซอร์หลัก</div>
    </div>
  </footer>

  <!-- Toast -->
  <!-- Notifications container (pre-created so Tailwind JIT includes classes used by pd2-notify.js) -->
  <!-- mobile responsive fix: constrain width and nudge position on small screens -->
  <div id="notifications" class="fixed top-2 right-2 sm:top-4 sm:right-4 z-50 space-y-2 max-w-[92vw] sm:max-w-none hidden" aria-hidden="true" role="region" aria-label="การแจ้งเตือนระบบ"></div>

  

  <!-- mobile responsive fix: constrain toast width and offsets on small screens -->
  <div id="toast" role="status" aria-live="polite" aria-atomic="true" class="fixed top-2 left-2 sm:top-4 sm:left-4 z-[100] px-4 py-2 rounded-lg glass text-white/95 text-sm shadow-lg opacity-0 pointer-events-none transition-opacity duration-300 text-left max-w-[92vw] sm:max-w-xs">
    
  </div>

  <script>
    (function(){
      const btnA = document.getElementById('btnA');
      const btnB = document.getElementById('btnB');
      const btnCut = document.getElementById('btnCut');
  const btnReport = document.getElementById('btnReport');
  let frame = document.getElementById('shiftFrame');
  // Hero buttons removed per request
      const toast = document.getElementById('toast');
  // Simple cache-busting token so GH Pages picks up latest subpages
  const CACHE_VER = '20250918b1';
  const withVer = (p) => `${encodeURI(p)}${p.includes('?') ? '&' : '?'}v=${CACHE_VER}`;

  // Lightweight debug logger for troubleshooting. Non-invasive.
  // It simply writes to console.debug with a PD2 prefix.
  const PD2Log = (...args) => { try { console.debug('[PD2]', ...args); } catch (_) {} };

      // Ensure the root page URL also carries a cache-busting token to avoid CDN-stale HTML on revisits
      (function ensureRootCacheBust(){
        try {
          const u = new URL(location.href);
          if (u.searchParams.get('cb') !== CACHE_VER) {
            u.searchParams.set('cb', CACHE_VER);
            history.replaceState(null, '', u.toString());
          }
        } catch (_) { /* no-op */ }
      })();

      // group for shared effects/helpers
  const pills = [btnA, btnB, btnCut, btnReport].filter(Boolean);

      function showToast(message) {
        if (!toast) return;
        toast.textContent = message;
        toast.classList.remove('opacity-0', 'pointer-events-none');
        toast.classList.add('opacity-100');
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => {
          toast.classList.add('opacity-0', 'pointer-events-none');
          toast.classList.remove('opacity-100');
        }, 1800);
      }

  function setActive(btnActive /*, ..._restIgnored */) {
        // Toggle state exclusively among all pills (A, B, Cut)
        pills.forEach(btn => {
          if (!btn) return;
          const isActive = btn === btnActive;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      // Shared session-only lists for cross-iframe sync
      const SHARED = { machines: [], fabricSizes: [
        // Merged + updated (2025-09-17) – ordering by first two leading digits ascending, then logically grouped; mixed/non-pure numeric prefixes at end
        "1425800",
        "1621720SMFX",
        "1625800",
        "1625800SM",
        "1725800",
        "1825800SM",
        "1921720",
        "19251000SM",
        "1925800",
        "1925800SM",
        "2021720UV",
        "2021750",
        "2021850UV",
        "20251000",
        "2025650",
        "2025700",
        "2025800",
        "2025800SM",
        "2025800SMN",
        "2025850",
        "2121670SM",
        "2125650",
        "2125700",
        "2125800",
        "2221940",
        "23211125120SMFX",
        "23211125130",
        "2321112514051",
        "2321112512551",
        "2321750",
        "2325650",
        "2325800SM",
        "2421112512551",
        "2625650",
        "262575051",
        "2625800",
        "2625850SM",
        "2825850",
        "1R042325650",
        "FCL022325650",
        "SCL0223211125",
        "scl052325650",
        "test2025800"
      ], employees: [] };
      const withSafeStr = (v) => (v == null ? '' : String(v).trim());

  function broadcastShared(targetWin) {
        const msg = { type: 'PD2_SYNC_CUSTOM', payload: {
          machines: SHARED.machines.slice(),
          fabricSizes: SHARED.fabricSizes.slice(),
          employees: SHARED.employees.slice()
        }};
        PD2Log('broadcastShared ->', { targetWin: !!targetWin, counts: { m: SHARED.machines.length, f: SHARED.fabricSizes.length, e: SHARED.employees.length } });
        const allowedOrigin = (function(){ try { return location.origin; } catch(_) { return '*'; }})();
        if (targetWin) {
          try { targetWin.postMessage(msg, allowedOrigin); } catch(err) { PD2Log('broadcastShared.postMessage.error', err); }
          return;
        }
        document.querySelectorAll('iframe').forEach(ifr => {
          try { ifr.contentWindow?.postMessage(msg, allowedOrigin); } catch(err) { PD2Log('broadcastShared.postMessage.error', err); }
        });
      }

      function upsertShared(kind, data) {
        if (kind === 'machine') {
          const v = withSafeStr(data?.value);
          if (v && !SHARED.machines.includes(v)) { SHARED.machines.push(v); PD2Log('upsertShared.machine', v); }
        } else if (kind === 'fabric') {
          const v = withSafeStr(data?.value);
          if (v && !SHARED.fabricSizes.includes(v)) { SHARED.fabricSizes.push(v); PD2Log('upsertShared.fabric', v); }
        } else if (kind === 'employee') {
          const id = withSafeStr(data?.id), name = withSafeStr(data?.name);
          if (id && name && !SHARED.employees.some(e => e.id === id)) { SHARED.employees.push({ id, name }); PD2Log('upsertShared.employee', { id, name }); }
        }
      }

      window.addEventListener('message', (ev) => {
        const m = ev?.data;
        if (!m || typeof m !== 'object') return;
        PD2Log('message.recv', m && m.type, { origin: ev.origin });
        // Only accept messages from the active iframe for privileged operations
        const fromActiveFrame = (function(){
          try { return ev.source === frame.contentWindow; } catch(_) { return false; }
        })();
        if (fromActiveFrame && m.type === 'PD2_ADD_CUSTOM' && m.category) {
          upsertShared(m.category, m.data);
          broadcastShared();
        } else if (fromActiveFrame && m.type === 'PD2_REQUEST_SYNC') {
          broadcastShared(ev.source);
        } else if (m.type === 'PD2_CENTERED_SUCCESS') {
          try {
            const count = typeof m.count === 'number' ? m.count : 0;
            if (window.PD2NotifyCenteredSuccess) {
              window.PD2NotifyCenteredSuccess(count);
            } else if (window.PD2Notify) {
              window.PD2Notify('สำเร็จ '+count+' รายการ','success');
            }
          } catch(_){ }
        }
      });

      // Robust navigation controller to prevent UI freeze when switching modules
  const loadingEl = document.getElementById('frameLoading');
      const loadingLabelEl = document.getElementById('frameLoadingLabel');
  const navState = { busy: false, token: 0, timer: null, retry: 0, pendingTarget: null, startedAt: 0, autoRecoveryAttempts: 0 };
  let currentModule = null; // 'A' | 'B' | 'CUT' | 'REPORT'
  // Multi-iframe cache (can be disabled via ?nocache=1 for fallback safety or debugging)
  const searchParams = (() => { try { return new URL(location.href).searchParams; } catch(_) { return new URLSearchParams(); } })();
  // Default to single-iframe (most stable). Enable multi-iframe explicitly with ?multiframe=1
  const MULTIFRAME = searchParams.get('multiframe') === '1';
  const BASE_NO_CACHE_MODE = !MULTIFRAME; // true => single iframe mode by default
  let NO_CACHE_OVERRIDE = null; // null=use base; true=force single; false=force multi
  function isNoCacheMode(){ return NO_CACHE_OVERRIDE === null ? BASE_NO_CACHE_MODE : NO_CACHE_OVERRIDE; }
  if (isNoCacheMode()) { console.info('[PD2_NAV] NO_CACHE_MODE active - using single iframe navigation'); }
  const frameCache = {}; // { A: HTMLIFrameElement, ... } (suppressed when isNoCacheMode() is true)
  const FRAME_CACHE_LIMIT = 3; // ถ้าเกินจะลบตัวที่ไม่ใช้งานนานสุด
  const frameUseOrder = []; // LRU tracking

  function touchFrameOrder(key){
    if (isNoCacheMode()) return; // skip LRU in no-cache mode
    const idx = frameUseOrder.indexOf(key);
    if (idx !== -1) frameUseOrder.splice(idx,1);
    frameUseOrder.push(key);
    if (frameUseOrder.length > FRAME_CACHE_LIMIT) {
      const evict = frameUseOrder.shift();
      if (evict && frameCache[evict] && evict !== currentModule) {
        try { frameCache[evict].remove(); } catch(_){ }
        delete frameCache[evict];
        console.info('[PD2_NAV] evict', evict);
      }
    }
  }
  const baseFrame = frame; // original placeholder iframe

  function getOrCreateFrame(target) {
    if (isNoCacheMode()) {
      // Always reuse single base frame
      return baseFrame;
    }
    if (frameCache[target]) { touchFrameOrder(target); return frameCache[target]; }
    const ifr = Object.keys(frameCache).length === 0 && baseFrame && !baseFrame.dataset.bound
      ? baseFrame
      : document.createElement('iframe');
    if (!ifr.parentNode) baseFrame.parentNode.appendChild(ifr);
    ifr.className = 'w-full h-full border-0 absolute inset-0';
    ifr.style.display = 'none';
    ifr.setAttribute('data-module', target);
    ifr.title = 'Shift Frame ' + target;
    ifr.dataset.bound = '1';
    frameCache[target] = ifr;
    touchFrameOrder(target);
    return ifr;
  }

  function showFrame(target) {
    if (!isNoCacheMode()) {
      Object.values(frameCache).forEach(f => { f.style.display = 'none'; });
    }
    const f = getOrCreateFrame(target);
    if (!isNoCacheMode()) {
      f.style.display = 'block';
    }
    frame = f;
    return f;
  }

      function setNavDisabled(disabled) {
        pills.forEach(b => { if (!b) return; b.disabled = disabled; });
      }
      function showLoading(label) {
        if (loadingLabelEl) loadingLabelEl.textContent = label || 'กำลังโหลดโมดูล...';
        if (loadingEl) loadingEl.classList.remove('loading-hidden');
      }
      function hideLoading() {
        if (loadingEl) loadingEl.classList.add('loading-hidden');
      }
      function pathFor(target) {
        if (target === 'A') return './ปรับ script PD2_Shift-A_V4.0/index.html';
        if (target === 'B') return './ปรับ script PD2_Shift-B_V4.0/index.html';
        if (target === 'CUT') return './ตัดม้วน PD2/index.html';
        if (target === 'REPORT') return './link google sheet/index.html';
        return './ปรับ script PD2_Shift-A_V4.0/index.html';
      }
      function buttonFor(target) {
        return target === 'A' ? btnA : target === 'B' ? btnB : target === 'CUT' ? btnCut : btnReport;
      }
      function updateHash(target) {
        try {
          const u = new URL(location.href);
          if (target === 'A') { u.hash = '#shift=A'; }
          else if (target === 'B') { u.hash = '#shift=B'; }
          else if (target === 'CUT') { u.hash = '#cut'; }
          else if (target === 'REPORT') { u.hash = '#report'; }
          history.replaceState(null, '', u.toString());
        } catch(_){}
      }
      function navigateTo(target, opts) {
        const options = Object.assign({ initial:false }, opts);
  if (!frame) { PD2Log('navigateTo.abort.no-frame', target); return; }
        // If selecting the same module and not forcing, ignore to prevent unnecessary reloads
        if (!options.force && currentModule === target) {
          return;
        }
        // Rapid switching handling:
        // If a navigation is in-flight, we don't just ignore. We either interrupt (if target already cached & loaded)
        // or queue the last requested target to auto-run after current load completes.
        if (navState.busy && !options.force) {
          const cachedWhileBusy = frameCache[target];
          if (cachedWhileBusy && cachedWhileBusy.dataset.loaded === '1') {
            // Interrupt current slow load and switch immediately to cached target
            console.info('[PD2_NAV] interrupt-cache-switch', target);
            try { clearTimeout(navState.timer); } catch(_){}
            // Invalidate previous navigation token so its load/ready handlers become stale no-ops
            navState.token += 1;
            navState.busy = false;
            navState.retry = 0;
            navState.pendingTarget = null;
            hideLoading();
            setNavDisabled(false);
            // Fast path identical to cache-hit logic below (duplicated for clarity inside interrupt scenario)
            const startInt = Date.now();
            showFrame(target);
            currentModule = target;
            setActive(buttonFor(target));
            updateHash(target);
            console.info('[PD2_NAV] cache-hit', target, { elapsedMs: Date.now() - startInt, interrupted: true });
            if (!options.initial) {
              showToast(target === 'A' ? 'สลับไปยังกะ A แล้ว' : target === 'B' ? 'สลับไปยังกะ B แล้ว' : target === 'CUT' ? 'เปิดหน้าตัดม้วน PD2 แล้ว' : 'เปิดหน้ารายงานแล้ว');
            }
            try { setTimeout(() => broadcastShared(cachedWhileBusy.contentWindow), 0); } catch(_){ }
            return;
          }
          // Queue latest desired target
          navState.pendingTarget = target;
          setActive(buttonFor(target)); // Optimistically reflect user's latest intent
          console.info('[PD2_NAV] queued', target);
          return;
        }
  PD2Log('navigateTo.start', target, opts);

  // If we already have a cached loaded iframe for this module, switch instantly (no network / reload)
  const cached = (!isNoCacheMode()) ? frameCache[target] : null;
  if (!isNoCacheMode() && cached && cached.dataset.loaded === '1' && !options.force) {
    const start = Date.now();
    showFrame(target);
    currentModule = target;
    setActive(buttonFor(target));
    setNavDisabled(false);
    updateHash(target);
    hideLoading();
    console.info('[PD2_NAV] cache-hit', target, { elapsedMs: Date.now() - start });
    if (!options.initial) {
      showToast(target === 'A' ? 'สลับไปยังกะ A แล้ว' : target === 'B' ? 'สลับไปยังกะ B แล้ว' : target === 'CUT' ? 'เปิดหน้าตัดม้วน PD2 แล้ว' : 'เปิดหน้ารายงานแล้ว');
    }
    // Broadcast shared state into the (now visible) iframe to ensure sync
    try { setTimeout(() => broadcastShared(cached.contentWindow), 0); } catch(_){}
    return;
  }

  // Slow path: first load for this module
  navState.busy = true; navState.token += 1; const myToken = navState.token; navState.retry = 0; navState.startedAt = Date.now();
        clearTimeout(navState.timer);
        const btn = buttonFor(target);
        setActive(btn);
        setNavDisabled(true);
        if (!options.initial) document.getElementById('workbench')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  showLoading(target === 'A' ? 'กำลังโหลด กะ A...' : target === 'B' ? 'กำลังโหลด กะ B...' : target === 'CUT' ? 'กำลังโหลด หน้าตัดม้วน...' : 'กำลังโหลด รายงาน...');
        updateHash(target);

        // Prepare (or create) iframe for this navigation
  const targetFrame = showFrame(target);
  try { targetFrame.dataset.navToken = String(myToken); } catch(_){}
        // Early readiness polling: if onload/PD2_READY lost but DOM becomes interactive/complete, finalize quickly
        (function earlyPoll(tok, mod, ifr){
          let attempts = 0;
          const max = 80; // ~8s @100ms (give heavy module A more room)
          function tick(){
            if (tok !== navState.token) return; // stale
            if (!navState.busy) return; // already finished
            try {
              const doc = ifr.contentDocument || ifr.contentWindow && ifr.contentWindow.document;
              if (doc && (doc.readyState === 'interactive' || doc.readyState === 'complete')) {
                // Basic heuristic: ensure some body content exists (even minimal) or substantial HTML rendered
                const hasBody = !!doc.body;
                const childCount = hasBody && doc.body.children ? doc.body.children.length : 0;
                const htmlLen = hasBody ? (doc.body.innerHTML || '').length : 0;
                if (hasBody && (childCount >= 1 || htmlLen > 200)) {
                  console.info('[PD2_NAV] early-poll-finalize', mod, { token: tok, readyState: doc.readyState });
                  try { ifr.dataset.loaded = '1'; } catch(_){ }
                  navState.busy = false; setNavDisabled(false); hideLoading(); navState.retry = 0;
                  currentModule = mod;
                  try { setTimeout(() => broadcastShared(ifr.contentWindow), 0); } catch(_){ }
                  if (navState.pendingTarget && navState.pendingTarget !== currentModule) {
                    const nxt = navState.pendingTarget; navState.pendingTarget = null; setTimeout(() => navigateTo(nxt), 0);
                  }
                  return;
                }
              }
            } catch(_){ }
            attempts++;
            if (attempts < max && navState.busy && tok === navState.token) setTimeout(tick, 100);
          }
          setTimeout(tick, 120);
        })(myToken, target, targetFrame);

  const onLoad = () => {
          // Stale load event from previous navigation? Ignore.
          if (myToken !== navState.token) return;
          if (targetFrame.dataset.navToken && targetFrame.dataset.navToken !== String(myToken)) return;
          PD2Log('navigateTo.onload', target, { token: myToken });
          try {
            const now = Date.now();
            const start = window.__pd2_nav_start || now;
            const elapsed = now - start;
            console.info('[PD2_NAV] onload', target, { token: myToken, elapsedMs: elapsed });
          } catch(_){}
          try { targetFrame.dataset.loaded = '1'; } catch(_){}
          clearTimeout(navState.timer);
          try { window.removeEventListener('message', onReadyMessage); } catch(_){}
          navState.busy = false; setNavDisabled(false); hideLoading(); navState.retry = 0;
          currentModule = target;
          // sync lists to the freshly loaded iframe
            try { setTimeout(() => broadcastShared(targetFrame.contentWindow), 0); } catch(_){ }
            // Apply mobile-only scroll lock inside iframe to prevent horizontal panning
            try { setTimeout(() => { applyMobileScrollLockToIframe(targetFrame?.contentDocument || targetFrame?.contentWindow?.document); }, 0); } catch(_){ }
          // toasts per module
          if (!options.initial) {
            showToast(target === 'A' ? 'สลับไปยังกะ A แล้ว' : target === 'B' ? 'สลับไปยังกะ B แล้ว' : target === 'CUT' ? 'เปิดหน้าตัดม้วน PD2 แล้ว' : 'เปิดหน้ารายงานแล้ว');
          }
          // Dequeue any pending target (last user intent) and navigate immediately
          if (navState.pendingTarget && navState.pendingTarget !== currentModule) {
            const nextTarget = navState.pendingTarget;
            navState.pendingTarget = null;
            console.info('[PD2_NAV] dequeue-after-load', nextTarget);
            setTimeout(() => navigateTo(nextTarget), 0);
          }
        };
        const onErrorTimeout = () => {
          if (myToken !== navState.token) return;
          PD2Log('navigateTo.timeout', target, { token: myToken, retry: navState.retry });
          if (navState.retry < 2) {
            navState.retry++;
            // progressive backoff
            const wait = navState.retry === 1 ? 350 : 700;
            if (loadingLabelEl) loadingLabelEl.textContent = 'โหลดช้า กำลังลองใหม่ ('+navState.retry+')...';
            try { frame.removeAttribute('src'); } catch(_){ }
            setTimeout(() => navigateTo(target, { force: true }), wait);
            return;
          }
          // Give control back but schedule background auto-recovery if user doesn't change
          try { window.removeEventListener('message', onReadyMessage); } catch(_){ }
          navState.busy = false; setNavDisabled(false); hideLoading();
          showToast('โหลดช้า กดเปลี่ยนโมดูลใหม่ หรือระบบจะลองกู้เอง');
          // schedule auto recovery (only if still same module desired and not cache loaded)
          if (!frameCache[target] || frameCache[target].dataset.loaded !== '1') {
            scheduleAutoRecovery(target);
          }
        };

        // Attach one-time load listener per navigation
  targetFrame.addEventListener('load', onLoad, { once: true });
        // Also accept an early 'PD2_READY' postMessage from the iframe when the iframe's UI is painted
  const onReadyMessage = (ev) => {
          try {
            const m = ev && ev.data;
            if (!m || typeof m !== 'object') return;
            // Compare message source to the specific targetFrame for this navigation (not the mutable global 'frame')
            const expectedWin = (function(){ try { return targetFrame && targetFrame.contentWindow; } catch(_) { return null; } })();
            if (m.type === 'PD2_READY' && expectedWin && ev.source === expectedWin) {
              // make sure it's for the current navigation token
              if (myToken !== navState.token) return;
              if (targetFrame.dataset.navToken && targetFrame.dataset.navToken !== String(myToken)) return;
              PD2Log('navigateTo.readyMsg', target, { token: myToken });
              try {
                const now = Date.now();
                const start = window.__pd2_nav_start || now;
                const elapsed = now - start;
                console.info('[PD2_NAV] PD2_READY', target, { token: myToken, elapsedMs: elapsed });
              } catch(_){}
              try { targetFrame.dataset.loaded = '1'; } catch(_){}
              try { clearTimeout(navState.timer); } catch(_){ }
              navState.busy = false; setNavDisabled(false); hideLoading(); navState.retry = 0; navState.autoRecoveryAttempts = 0;
                navState.busy = false; setNavDisabled(false); hideLoading(); navState.retry = 0; navState.autoRecoveryAttempts = 0;
              currentModule = target;
              try { setTimeout(() => broadcastShared(frame.contentWindow), 0); } catch(_){ }
              // Apply mobile-only scroll lock inside iframe to prevent horizontal panning
              try { setTimeout(() => { applyMobileScrollLockToIframe(frame?.contentDocument || frame?.contentWindow?.document); }, 0); } catch(_){ }
              // (deduped repeated broadcast & scroll-lock injections that were previously triplicated)
              try { setTimeout(() => broadcastShared(targetFrame.contentWindow), 0); } catch(_){ }
              try { setTimeout(() => { applyMobileScrollLockToIframe(targetFrame?.contentDocument || targetFrame?.contentWindow?.document); }, 0); } catch(_){ }
              if (!options.initial) {
                try { showToast(target === 'A' ? 'สลับไปยังกะ A แล้ว' : target === 'B' ? 'สลับไปยังกะ B แล้ว' : target === 'CUT' ? 'เปิดหน้าตัดม้วน PD2 แล้ว' : 'เปิดหน้ารายงานแล้ว'); } catch(_){}
              }
              // remove listener (one-time)
              try { window.removeEventListener('message', onReadyMessage); } catch(_){}
              // If user queued another target while we were loading, jump there now.
              if (navState.pendingTarget && navState.pendingTarget !== currentModule) {
                const nextTarget = navState.pendingTarget;
                navState.pendingTarget = null;
                console.info('[PD2_NAV] dequeue-after-ready', nextTarget);
                setTimeout(() => navigateTo(nextTarget), 0);
              }
            }
          } catch(_){}
        };
  window.addEventListener('message', onReadyMessage);
    // Kick off navigation (instrumentation: record start time for switch latency)
  try {
    var __pd2_nav_token = (window.__pd2_nav_token || 0) + 1;
    window.__pd2_nav_token = __pd2_nav_token;
    window.__pd2_nav_start = Date.now();
    PD2Log('navigateTo.setSrc', withVer(pathFor(target)), { token: __pd2_nav_token, start: window.__pd2_nav_start });
    console.info('[PD2_NAV] start', target, { token: __pd2_nav_token, start: window.__pd2_nav_start });
  } catch (_) {}
  targetFrame.src = withVer(pathFor(target));
        // Watchdog timeout to recover UI even if load doesn't fire
  navState.timer = setTimeout(onErrorTimeout, 10000);
      }

      // Wire buttons to new navigator
        // Wire buttons to new navigator with lightweight debounce to avoid rapid-fire races
        const __pd2_clickGate = { last: 0 };
        function withDebounce(handler, waitMs) {
          const wait = typeof waitMs === 'number' ? waitMs : 220;
          return (...args) => {
            const now = Date.now();
            if (now - __pd2_clickGate.last < wait) return;
            __pd2_clickGate.last = now;
            handler(...args);
          };
        }
        btnA.addEventListener('click', withDebounce(() => navigateTo('A')));
        btnB.addEventListener('click', withDebounce(() => navigateTo('B')));
        if (btnCut) btnCut.addEventListener('click', withDebounce(() => navigateTo('CUT')));
        if (btnReport) btnReport.addEventListener('click', withDebounce(() => navigateTo('REPORT')));
      // System Reset Button (Deep Clean & Reload)
      (function(){
        const wrap = document.getElementById('pd2ResetWrap');
        const btn = document.getElementById('pd2ResetBtn');
        const menu = document.getElementById('pd2ResetMenu');
        if(!btn || !menu) return;

        function toggleMenu(force){
          const show = force !== undefined ? force : menu.classList.contains('hidden');
          menu.classList.toggle('hidden', !show);
        }
        btn.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
        document.addEventListener('click', (e) => { if(!wrap.contains(e.target)) toggleMenu(false); });

        async function performReset(mode){
          if (navState.busy) { showToast('กำลังโหลดอยู่ รอสักครู่...'); return; }
          const modeLabel = mode === 'partial' ? 'บางส่วน' : 'ทั้งหมด';
          console.info('[PD2_RESET] start', { mode });
          showToast('รีเซ็ต'+modeLabel+'...');
          // 1. Always clear iframe cache
          try {
            Object.keys(frameCache).forEach(k => { try { frameCache[k].remove(); } catch(_){}; delete frameCache[k]; });
            console.info('[PD2_RESET] iframe cache cleared');
          } catch(err){ console.warn('[PD2_RESET] iframe cache error', err); }
          // 2. localStorage: partial keeps user form data (values) but clears meta caches; full clears PD2 keys
          try {
            const keys = []; for (let i=0;i<localStorage.length;i++){ const k = localStorage.key(i); if(k) keys.push(k); }
            const PD2_KEYS = keys.filter(k => /pd2|shift|wage|machine|fabric|employee|errorLog|productionData/i.test(k));
            if (mode === 'full') {
              PD2_KEYS.forEach(k => { try { localStorage.removeItem(k); } catch(_){ } });
              console.info('[PD2_RESET] localStorage removed (full)', PD2_KEYS);
            } else {
              // partial: เก็บข้อมูลทุกอย่างที่ผู้ใช้กรอก (shift, wage, machine, fabric, employee, productionData ฯลฯ)
              // ลบเฉพาะ key ที่เป็น log / error / debug / cache เพื่อลดสิ่งค้าง
              const REMOVE_PAT = /(errorlog|_log|logs?|cache|_cache|debug)/i;
              const toRemove = PD2_KEYS.filter(k => REMOVE_PAT.test(k));
              toRemove.forEach(k => { try { localStorage.removeItem(k); } catch(_){ } });
              console.info('[PD2_RESET] localStorage removed (partial, only log/cache keys)', toRemove);
            }
          } catch(err){ console.warn('[PD2_RESET] ls error', err); }
          // 3. CacheStorage & SW always cleared (both modes) → ลดความสับสนเรื่องไฟล์เก่า
          try { if (window.caches && caches.keys) { const names = await caches.keys(); await Promise.all(names.map(n => caches.delete(n))); console.info('[PD2_RESET] CacheStorage cleared', names); } } catch(err){ console.warn('[PD2_RESET] cacheStorage error', err); }
          try { if (navigator.serviceWorker) { const regs = await navigator.serviceWorker.getRegistrations(); await Promise.all(regs.map(r => r.unregister())); console.info('[PD2_RESET] service workers unregistered'); } } catch(err){ console.warn('[PD2_RESET] sw unregister error', err); }
          // 4. Reset nav state
          try { navState.pendingTarget = null; navState.busy = false; navState.token += 1; } catch(_){ }
          // 5. Reload (full: add resetts; partial: add softts param)
          setTimeout(() => {
            const u = new URL(location.href);
            u.searchParams.set(mode === 'full' ? 'resetts' : 'softts', Date.now());
            location.replace(u.toString());
          }, 120);
        }

        menu.querySelectorAll('.pd2-reset-item').forEach(item => {
          item.addEventListener('click', (e) => {
            const mode = item.getAttribute('data-mode');
            toggleMenu(false);
            performReset(mode);
          });
        });
      })();

      // CTA buttons on overview cards
  // (no hero CTA handlers)

      // Deep-link support: .../index.html#shift=B or #cut -> open initially using navigator
      const hash = (location.hash || '').toLowerCase();
      if (hash.includes('shift=b')) {
        PD2Log('initialHash', 'B');
        navigateTo('B', { initial: true });
      } else if (hash.includes('shift=cut') || hash === '#cut' || hash.includes('module=cut')) {
        PD2Log('initialHash', 'CUT');
        navigateTo('CUT', { initial: true });
      } else if (hash.includes('report')) {
        PD2Log('initialHash', 'REPORT');
        navigateTo('REPORT', { initial: true });
      }

      // Prefetch / warm-up module HTML in idle time to reduce perceived load delay
      function prefetchModules() {
        if (isNoCacheMode()) return; // skip prefetching in single-frame mode
        try {
          const targets = ['A','B','CUT','REPORT'];
          const run = () => {
            if (document.hidden) { return; }
            targets.forEach(t => {
              if (t === currentModule) return; // skip already loaded
              const p = withVer(pathFor(t));
              PD2Log('prefetch.attempt', t, p);
              fetch(p, { method: 'GET', credentials: 'same-origin', cache: 'force-cache' })
                .then(r => { if (r.ok) PD2Log('prefetch.ok', t, { status: r.status }); else PD2Log('prefetch.non-2xx', t, { status: r.status }); })
                .catch(e => PD2Log('prefetch.err', t, { error: String(e) }));
            });
          };
          if ('requestIdleCallback' in window) {
            requestIdleCallback(() => run(), { timeout: 2000 });
          } else {
            setTimeout(run, 1500);
          }
        } catch (err) { PD2Log('prefetch.fail', String(err)); }
      }

      // Trigger prefetch after initial navigation settled
      setTimeout(prefetchModules, 800);
      // Idle preload: instantiate hidden iframes for modules not yet visited so first switch is instant
      function idlePreloadFrames(){
        if (isNoCacheMode()) return; // no multi-frame preload
        try {
          const modules = ['A','B','CUT','REPORT'];
          const needed = modules.filter(m => !frameCache[m]);
          if (!needed.length) return;
          needed.forEach(m => {
            // Skip currently active (already created by navigate)
            if (m === currentModule) return;
            const ifr = getOrCreateFrame(m);
            // Mark as preloading
            ifr.dataset.preloading = '1';
            const url = withVer(pathFor(m));
            ifr.addEventListener('load', () => {
              ifr.dataset.loaded = '1';
              delete ifr.dataset.preloading;
              console.info('[PD2_NAV] preload.loaded', m);
              // Broadcast shared state so that when user switches it's already populated
              try { broadcastShared(ifr.contentWindow); } catch(_){ }
            }, { once: true });
            ifr.src = url;
            console.info('[PD2_NAV] preload.start', m, url);
          });
        } catch(err) { console.debug('[PD2_NAV] preload.error', err); }
      }
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => idlePreloadFrames(), { timeout: 4000 });
      } else {
        setTimeout(idlePreloadFrames, 1800);
      }
      // Respond to manual hash changes to keep iframe in sync
      window.addEventListener('hashchange', () => {
        try {
          const hh = (location.hash || '').toLowerCase();
          if (hh.includes('shift=b')) { navigateTo('B'); }
          else if (hh.includes('shift=a')) { navigateTo('A'); }
          else if (hh.includes('shift=cut') || hh === '#cut' || hh.includes('module=cut')) { navigateTo('CUT'); }
          else if (hh.includes('report')) { navigateTo('REPORT'); }
        } catch(_) {}
      });

      // Cleanup timers/listeners on page hide to avoid any stuck states on return
      const cleanupNav = () => { try { clearTimeout(navState.timer); } catch(_){} };
      window.addEventListener('pagehide', cleanupNav);
      window.addEventListener('beforeunload', cleanupNav);
      // Watchdog: prevent permanent freeze if iframe load events never fire (e.g., network stall, blocked resource)
      setInterval(() => {
        try {
          if (!navState.busy) return;
          const elapsed = Date.now() - (navState.startedAt || Date.now());
          if (elapsed > 12000) { // 12s hard timeout
            console.warn('[PD2_NAV] watchdog-hard-timeout', { elapsed, token: navState.token, pending: navState.pendingTarget });
            try { clearTimeout(navState.timer); } catch(_){}
            navState.busy = false; setNavDisabled(false); hideLoading();
            // Auto-degrade session to single-iframe mode for maximum stability
            try {
              if (!isNoCacheMode()) {
                NO_CACHE_OVERRIDE = true;
                // Drop extra iframes and keep base frame only
                try {
                  Object.keys(frameCache).forEach(k => {
                    const ifr = frameCache[k];
                    if (ifr !== baseFrame) { try { ifr.remove(); } catch(_){} }
                    delete frameCache[k];
                  });
                  frameCache[currentModule || 'A'] = baseFrame;
                } catch(_){}
                // Ensure base frame is visible and reload current target for a clean state
                try {
                  baseFrame.className = 'w-full h-full border-0 absolute inset-0';
                  baseFrame.style.display = 'block';
                  frame = baseFrame;
                  const tgt = currentModule || 'A';
                  const url = withVer(pathFor(tgt));
                  setTimeout(() => { try { baseFrame.src = url; } catch(_){} }, 50);
                  showToast('สลับเป็นโหมดเสถียร (Single iframe)');
                  console.info('[PD2_NAV] degraded-to-single-iframe');
                } catch(_){}
              }
            } catch(_){}
            // If we have a pending target, try that next
            if (navState.pendingTarget) {
              const tgt = navState.pendingTarget; navState.pendingTarget = null;
              setTimeout(() => navigateTo(tgt, { force: true }), 0);
            }
            return;
          }
          if (elapsed > 6500) { // soft recovery attempt
            // If current target frame actually loaded DOM (readyState) but events missed, finalize manually
            const activeFrame = frame;
            if (activeFrame && activeFrame.contentDocument && activeFrame.contentDocument.readyState !== 'loading') {
              console.warn('[PD2_NAV] watchdog-soft-complete', { elapsed, token: navState.token });
              navState.busy = false; setNavDisabled(false); hideLoading(); navState.retry = 0;
              try { activeFrame.dataset.loaded = '1'; } catch(_){}
              if (navState.pendingTarget) {
                const tgt2 = navState.pendingTarget; // fixed previously broken identifier split across lines
                navState.pendingTarget = null;
                setTimeout(() => navigateTo(tgt2), 0);
              }
            }
          }
        } catch(_){}
      }, 1500);
      // Auto recovery scheduler: if navigation gave up, try a limited number of background reloads unless user interacted
      function scheduleAutoRecovery(target){
        try {
          if (navState.autoRecoveryAttempts >= 3) return;
          navState.autoRecoveryAttempts++;
          const attemptNo = navState.autoRecoveryAttempts;
          const delay = attemptNo * 2500; // 2.5s, 5s, 7.5s
          console.info('[PD2_NAV] auto-recover-scheduled', target, { attempt: attemptNo, delay });
          setTimeout(() => {
            // If user already switched or module loaded, abort
            if (currentModule === target || (frameCache[target] && frameCache[target].dataset.loaded === '1')) {
              console.info('[PD2_NAV] auto-recover-abort', target, { attempt: attemptNo });
              return;
            }
            console.info('[PD2_NAV] auto-recover-attempt', target, { attempt: attemptNo });
            navigateTo(target, { force: true });
          }, delay);
        } catch(_){}
      }
      
        // Fancy shine effect: track mouse to set --x hotspot for pills
  pills.forEach(btn => {
          btn.addEventListener('pointermove', (e) => {
            const rect = btn.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100; // percent across
            btn.style.setProperty('--x', x + '%');
          });
          btn.addEventListener('pointerleave', () => btn.style.removeProperty('--x'));
  });

  // initial navigation via controller (defaults to A)
  if (!frame.src || frame.src === 'about:blank') {
    navigateTo('A', { initial: true });
  }

  // Helper: Inject mobile-only CSS and touch handler into iframe to lock scrolling to vertical on small screens
  function applyMobileScrollLockToIframe(doc){
    try {
      if (!doc) return;
      const isMobile = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
      if (!isMobile) return; // only on small screens
      const head = doc.head || doc.getElementsByTagName('head')[0] || doc.documentElement;
      if (!head) return;

      // Inject CSS once
      if (!doc.getElementById('pd2-mobile-scroll-lock')) {
        const style = doc.createElement('style');
        style.id = 'pd2-mobile-scroll-lock';
        style.type = 'text/css';
  style.textContent = `
@media (max-width: 767px) {
  html, body {
    max-width: 100% !important;
    overflow-x: hidden !important;
    overscroll-behavior-x: contain;
    touch-action: pan-y;
    -webkit-overflow-scrolling: touch;
  }
  body, main, .container, .wrapper, .content, .module, .inner, .inner-module, .page, .sheet {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }
  /* Prevent flex/grid children from overflowing horizontally */
  main > *, .container > *, .wrapper > *, .content > *, .module > *, .inner > *, .inner-module > *, .page > *, .sheet > * {
    min-width: 0;
    max-width: 100%;
    box-sizing: border-box;
    word-wrap: break-word;
  }
  img { max-width: 100%; height: auto; display: block; }
  table { width: 100%; table-layout: fixed; word-break: break-word; }
  /* Encourage vertical scrolling only within common containers */
  .inner-module, .module, main, .content, .wrapper, .page, .sheet {
    overflow-x: hidden !important;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    touch-action: pan-y;
  }
  /* Opt-in horizontal scrolling areas when necessary */
  [data-allow-x] {
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch;
    touch-action: pan-x !important;
  }
}
        `;
        head.appendChild(style);
      }

      // Attach a conservative touch handler to block predominantly horizontal pans
      if (!doc.__pd2ScrollLockAttached) {
        doc.__pd2ScrollLockAttached = true;
        let startX = 0, startY = 0;
        doc.addEventListener('touchstart', function(e){
          const t = e.touches && e.touches[0];
          if (!t) return;
          startX = t.clientX; startY = t.clientY;
        }, { passive: true });
        doc.addEventListener('touchmove', function(e){
          try {
            if (!window.matchMedia || !window.matchMedia('(max-width: 767px)').matches) return; // guard on resize
            if (!e.touches || e.touches.length !== 1) return;
            const t = e.touches[0];
            const dx = Math.abs(t.clientX - startX);
            const dy = Math.abs(t.clientY - startY);
            // Opt-out: allow horizontal gestures inside elements explicitly marked
            const allowX = e.target && e.target.closest && e.target.closest('[data-allow-x]');
            if (!allowX && dx > dy) {
              e.preventDefault(); // block horizontal pan
            }
          } catch(_) { /* no-op */ }
        }, { passive: false });
      }
    } catch(_) { /* no-op */ }
  }
        
  // Mobile viewport adjustments
  // Fixes for mobile browser UI (dynamic URL bars, virtual keyboard) by
  // sizing iframe and nudging fixed elements using visualViewport where available.
  function adjustForMobile() {
    try {
      const header = document.querySelector('header');
      const headerH = header ? header.getBoundingClientRect().height : 112;
      const vv = window.visualViewport;
      const vh = vv ? vv.height : window.innerHeight;
      const offsetTop = vv ? vv.offsetTop : 0;

      // Set iframe & wrapper height to fit the visible viewport below header
      if (frame) {
        const targetH = Math.max(120, vh - headerH - 8); // keep a sane min-height
        frame.style.height = targetH + 'px';
        const wrap = document.querySelector('.frame-wrap');
        if (wrap) wrap.style.height = targetH + 'px';
      }

      // Move notification container / toast away from virtual keyboard or unsafe areas
      const notes = document.getElementById('notifications');
      if (notes) {
        notes.style.top = (16 + Math.max(0, offsetTop)) + 'px';
        notes.style.right = '12px';
      }
      const toast = document.getElementById('toast');
      if (toast) toast.style.top = (16 + Math.max(0, offsetTop)) + 'px';
    } catch (_) { /* no-op */ }
  }

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', adjustForMobile);
    window.visualViewport.addEventListener('scroll', adjustForMobile);
  } else {
    window.addEventListener('resize', adjustForMobile);
    window.addEventListener('orientationchange', adjustForMobile);
  }
  window.addEventListener('load', adjustForMobile);
  setTimeout(adjustForMobile, 400);
    })();
  </script>
  <!-- Fallback: ensure pd2-notify.js is available at runtime -->
  <script>
    (function(){
      try {
        if (typeof window.PD2Notify === 'function') {
          console.debug('PD2Notify already present');
          return;
        }
        console.debug('PD2Notify missing — attempting dynamic load of ./pd2-notify.js');
        var s = document.createElement('script');
        s.src = './pd2-notify.js';
        s.onload = function(){ console.debug('pd2-notify.js loaded dynamically, PD2Notify typeof:', typeof window.PD2Notify); if(typeof window.PD2Notify==='function') window.PD2Notify('Notification module loaded','success'); };
        s.onerror = function(e){ console.error('Failed to dynamically load pd2-notify.js', e); };
        document.head.appendChild(s);
      } catch (err) { try { console.error('pd2-notify fallback error', err); } catch(_){} }
    })();
  </script>
      <!-- Dev: websocket client to trigger iframe reload on file changes -->
      <script>
        (function(){
          try {
            const WS_URL = 'ws://127.0.0.1:35729';
            const socket = new WebSocket(WS_URL);
            socket.addEventListener('open', () => console.debug('[dev-ws] connected to', WS_URL));
            socket.addEventListener('message', (ev) => {
              try {
                const m = JSON.parse(ev.data || '{}');
                if (m && m.type === 'reload') {
                  console.debug('[dev-ws] reload event, path=', m.path);
                  try {
                    const frame = document.getElementById('shiftFrame');
                    if (frame && frame.contentWindow) {
                      // force reload of iframe content (cache-bust with timestamp)
                      const src = frame.src.split('?')[0];
                      frame.src = src + '?v=' + Date.now();
                    } else {
                      // fallback: reload parent
                      location.reload();
                    }
                  } catch(err) { console.error('[dev-ws] reload failed', err); }
                }
              } catch(_){}
            });
            socket.addEventListener('close', () => console.debug('[dev-ws] disconnected'));
          } catch(_){}
        })();
      </script>
      <!-- Register service worker to enable installation on supporting browsers -->
      <script>
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').then(reg => {
              console.debug('PD2: service worker registered', reg.scope);
            }).catch(err => { console.debug('PD2: sw registration failed', err); });
          });
        }
      </script>
</body>
</html>
